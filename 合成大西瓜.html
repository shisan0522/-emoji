<!doctype html>
<html lang="zh-CN">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>åˆæˆEmoji - é‡åŠ›ç‰ˆ</title>
<style>
  :root{
    --bg1: #fff6ea; /* å¥¶æ²¹ */
    --bg2: #ffeaf0; /* ç²‰ */
    --card: rgba(255,255,255,0.6);
    --accent: #ff7aa2;
    --shadow: 0 8px 28px rgba(16,16,16,0.12);
    --glass: rgba(255,255,255,0.5);
  }
  html,body{height:100%;margin:0;-webkit-user-select:none;user-select:none;touch-action:manipulation;}
  body{
    background: linear-gradient(160deg,var(--bg1),var(--bg2));
    font-family: "Helvetica Neue", "PingFang SC", "Noto Sans", Arial, sans-serif;
    -webkit-font-smoothing:antialiased;
    display:flex;
    align-items:center;
    justify-content:center;
    padding:env(safe-area-inset-bottom) 0 env(safe-area-inset-bottom);
    height:100vh;
    box-sizing:border-box;
  }
  .app{width:100%;max-width:460px;height:100%;display:flex;flex-direction:column;gap:10px;padding:14px;box-sizing:border-box;}
  header{display:flex;align-items:center;justify-content:space-between;gap:8px;}
  .title{display:flex;gap:10px;align-items:center;}
  .logo{width:48px;height:48px;border-radius:12px;background:linear-gradient(135deg,#fff,#ffe6f0);display:flex;align-items:center;justify-content:center;font-size:22px;box-shadow:var(--shadow);}
  h1{font-size:16px;margin:0;color:#38242a;font-weight:700}
  p.sub{margin:0;font-size:12px;color:#6a4d52;opacity:0.9}
  .controls{display:flex;gap:8px;align-items:center}
  button{border:0;padding:8px 12px;border-radius:12px;background:var(--card);backdrop-filter:blur(6px);box-shadow:var(--shadow);font-weight:600;color:#38242a;}
  button.small{padding:6px 8px;font-size:13px}
  .board-wrap{flex:1;display:flex;align-items:center;justify-content:center;}
  .board{width:100%;height:100%;border-radius:18px;background: linear-gradient(180deg, rgba(255,255,255,0.4), rgba(255,255,255,0.24));box-shadow: 0 12px 36px rgba(19,15,20,0.12);position:relative;overflow:hidden;padding:14px;box-sizing:border-box;touch-action: none;-webkit-tap-highlight-color: transparent;}
  .tile{position:absolute;display:flex;align-items:center;justify-content:center;border-radius:14px;font-size:26px;width:56px;height:56px;user-select:none;touch-action:none;transition:transform 160ms cubic-bezier(.2,.9,.3,1), box-shadow 160ms;will-change:transform,left,top;background:linear-gradient(180deg, rgba(255,255,255,0.95), rgba(255,255,255,0.9));box-shadow: 0 8px 20px rgba(0,0,0,0.08);border: 1px solid rgba(0,0,0,0.03);}
  .tile.dragging{z-index:999; transform:scale(1.06); box-shadow: 0 18px 36px rgba(0,0,0,0.18);}
  .hud{display:flex;align-items:center;gap:10px;}
  .hint{font-size:13px;color:#5e3d40;background:var(--glass);padding:8px 10px;border-radius:12px;box-shadow:0 6px 18px rgba(0,0,0,0.06);}
  footer{display:flex;justify-content:space-between;align-items:center;padding-top:6px;}
  .msg{font-size:13px;color:#6a4d52}
  .small{font-size:12px;color:#6a4d52;opacity:0.9}
  .overlay{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;background:linear-gradient(180deg, rgba(255,255,255,0.04), rgba(255,255,255,0.02));pointer-events:none;}
  .win{pointer-events:auto;background:linear-gradient(180deg,#fff,#ffeaf3);border-radius:18px;padding:18px 20px;text-align:center;box-shadow:var(--shadow);}
  @media (min-width:800px){.app{height:820px;border-radius:18px;padding:18px;background:transparent}}
</style>
</head>
<body>
<div class="app" id="app">
  <header>
    <div class="title">
      <div class="logo">ğŸ¬</div>
      <div>
        <h1>åˆæˆEmojiï¼ˆé‡åŠ›ç‰ˆï¼‰</h1>
        <p class="sub">æ‘‡ä¸€æ‘‡æ‰‹æœºè®©é‡Œé¢çš„è¡¨æƒ…è·Ÿç€æ‰è½</p >
      </div>
    </div>
    <div class="controls">
      <div class="hud"><div class="hint" id="score">åˆ†æ•°: 0</div></div>
      <button id="resetBtn" class="small">é‡ç½®</button>
      <button id="shareBtn" class="small">åˆ†äº«</button>
    </div>
  </header>

  <div class="board-wrap">
    <div class="board" id="board" aria-label="gameboard">
      <div id="overlay" class="overlay" style="display:none">
        <div class="win" id="winBox">
          <div id="winEmoji" style="font-size:44px">ğŸ‰</div>
          <h3 style="margin:8px 0 4px;color:#4a2a2f">ä½ åˆæˆåˆ°æœ€é«˜ç­‰çº§å•¦ï¼</h3>
          <p class="small" style="margin:0 0 12px;color:#5c3a3f">ç»§ç»­ç©æˆ–ç‚¹å‡»é‡ç½®ï½</p >
          <div style="display:flex;gap:8px;justify-content:center">
            <button id="winReset">å†æ¥ä¸€æ¬¡</button>
            <button id="closeWin" style="background:transparent;">ç»§ç»­</button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <footer>
    <div class="msg">æç¤ºï¼šæ‹–åŠ¨ç›¸åŒè¡¨æƒ…åˆæˆæ›´é«˜çº§ï¼›ä¹Ÿå¯ä»¥å€¾æ–œæ‰‹æœºè®©å®ƒä»¬æ»‘åŠ¨</div>
    <div class="small">ä½¿ç”¨å…¬å¼€ Emoji â€¢ å…ç‰ˆæƒ</div>
  </footer>
</div>

<script>
/* â€”â€” é…ç½®åŒº â€”â€” */
const EMOJIS = ["ğŸ¥º","ğŸ¤¤","ğŸ¥°","ğŸ‘","ğŸ“","ğŸ","ğŸ‰","ğŸ‹","ğŸ¥","ğŸ”","ğŸ¥","ğŸ¤","ğŸ¥®","ğŸ˜","ğŸ‚","ğŸ®","â¤ï¸"];
const BASE_LEVEL = 0;
const SPAWN_COUNT_INITIAL = 5;
const MAX_TILES = 20;
const BOARD_PADDING = 12;
const MERGE_DISTANCE_FACTOR = 0.45; // åˆæˆé˜ˆå€¼å› å­
const GRAVITY_SCALE = 0.8; // é‡åŠ›å¼ºåº¦è°ƒèŠ‚
const FRICTION = 0.98; // é€Ÿåº¦é˜»å°¼
/* â€”â€” ç»“æŸé…ç½® â€”â€” */

const board = document.getElementById('board');
const resetBtn = document.getElementById('resetBtn');
const shareBtn = document.getElementById('shareBtn');
const scoreEl = document.getElementById('score');
const overlay = document.getElementById('overlay');
const winEmoji = document.getElementById('winEmoji');
const winReset = document.getElementById('winReset');
const closeWin = document.getElementById('closeWin');

let tiles = []; // {id, level, el, x,y,size, vx,vy}
let score = 0;
let tileIdCounter = 1;
let boardRect = null;
let gravity = {x:0, y:0.6}; // é»˜è®¤æœä¸‹
let lastTimestamp = null;
let animationRunning = true;

// ------- åˆå§‹åŒ–ä¸å·¥å…·å‡½æ•° -------
function measureBoard(){ boardRect = board.getBoundingClientRect(); }
function updateScore(){ scoreEl.textContent = 'åˆ†æ•°: ' + score; }
function randomPosition(size){
  const pad = BOARD_PADDING + 8;
  const minX = pad;
  const maxX = Math.max(minX, boardRect.width - size - pad);
  const minY = pad;
  const maxY = Math.max(minY, boardRect.height - size - pad - 60);
  return { x: minX + Math.random()*(maxX-minX), y: minY + Math.random()*(maxY-minY) };
}
function findTileIndexById(id){ return tiles.findIndex(t => t.id === id); }
function safeRemoveTileById(id){
  const idx = findTileIndexById(id); if(idx === -1) return; const t = tiles[idx];
  try{ if(t.el && t.el.parentNode) t.el.parentNode.removeChild(t.el); }catch(e){} tiles.splice(idx,1);
}

// åˆ›å»º tile DOM å¹¶åŠ å…¥æ•°ç»„
function createTile(level, x, y, size){
  const id = 't' + (tileIdCounter++);
  const el = document.createElement('div');
  el.className = 'tile';
  el.style.width = size + 'px';
  el.style.height = size + 'px';
  el.style.left = x + 'px';
  el.style.top = y + 'px';
  el.dataset.id = id;
  el.dataset.level = level;
  el.innerHTML = '<span class="emoji" aria-hidden="true" style="line-height:1; font-size:' + Math.round(size*0.55) + 'px">' + EMOJIS[level] + '</span>';
  board.appendChild(el);
  const tile = { id, level, el, x, y, size, vx:0, vy:0, mass: 1 + level*0.15 };
  tiles.push(tile);
  makeDraggable(el);
  return tile;
}

function spawnRandom(level){
  if(tiles.length >= MAX_TILES) return false;
  const size = 56 + level*6;
  const p = randomPosition(size);
  return createTile(level, p.x, p.y, size);
}

// è‹¥å½“å‰æ²¡æœ‰ä»»ä½•å¯åˆå¹¶å¯¹ï¼Œå¼ºè¡Œæ”¾ä¸€å¯¹å¯åˆå¹¶çš„åŸºç¡€å—ï¼ˆé¿å…æ­»å±€ï¼‰
function ensurePossibleMerge(){
  if(tiles.length < 2) return;
  if(possibleMergeExists()) return;
  // æ‰¾ä¸€ä¸ªç©ºä½ç½®æˆå¯¹ç”Ÿæˆä¸¤ä¸ªåŒçº§å—ï¼Œé å¾—æ¯”è¾ƒè¿‘
  const level = BASE_LEVEL;
  const size = 56 + level*6;
  const p = randomPosition(size*1.2);
  // åˆ›å»ºä¸¤ä¸ªé è¿‘çš„
  createTile(level, p.x, p.y, size);
  createTile(level, Math.min(boardRect.width - size - 8, p.x + size*0.6), Math.min(boardRect.height - size - 8, p.y + size*0.1), size);
}

// åˆ¤æ–­æ˜¯å¦å­˜åœ¨å¯åˆå¹¶å¯¹ï¼ˆåŒçº§ä¸”è·ç¦»å°äºé˜ˆå€¼ï¼‰
function possibleMergeExists(){
  for(let i=0;i<tiles.length;i++){
    for(let j=i+1;j<tiles.length;j++){
      if(tiles[i].level !== tiles[j].level) continue;
      const ax = tiles[i].x + tiles[i].size/2, ay = tiles[i].y + tiles[i].size/2;
      const bx = tiles[j].x + tiles[j].size/2, by = tiles[j].y + tiles[j].size/2;
      const d = Math.hypot(ax-bx, ay-by);
      const thresh = (tiles[i].size + tiles[j].size) * MERGE_DISTANCE_FACTOR * 1.05;
      if(d <= thresh) return true;
    }
  }
  return false;
}

// æ‰¾åˆ°è·ç¦»æœ€è¿‘çš„ tile
function findNearest(tile){
  const cx = tile.x + tile.size/2, cy = tile.y + tile.size/2;
  let best = null; let bestDist = Infinity;
  for(const t of tiles){
    if(t.id === tile.id) continue;
    const tx = t.x + t.size/2, ty = t.y + t.size/2;
    const dx = tx - cx, dy = ty - cy;
    const dist = Math.hypot(dx,dy);
    if(dist < bestDist){ bestDist = dist; best = t; }
  }
  return {tile: best, dist: bestDist};
}

// åˆæˆæ£€æµ‹
function tryMerge(a,b){
  if(!a || !b) return false;
  if(a.level !== b.level) return false;
  const ax = a.x + a.size/2, ay = a.y + a.size/2;
  const bx = b.x + b.size/2, by = b.y + b.size/2;
  const d = Math.hypot(ax-bx, ay-by);
  return d <= (a.size + b.size) * MERGE_DISTANCE_FACTOR;
}

function doMerge(source, target){
  if(!source || !target) return;
  if(source.id === target.id) return;
  if(source.level !== target.level) return;
  const nextLevel = Math.min(source.level + 1, EMOJIS.length - 1);
  // target å‡çº§ï¼šæ›´æ–° levelã€sizeã€æ–‡æœ¬ã€font-size
  target.level = nextLevel;
  target.el.dataset.level = nextLevel;
  target.size = 56 + nextLevel*6;
  const emojiSpan = target.el.querySelector('.emoji');
  if(emojiSpan) emojiSpan.textContent = EMOJIS[nextLevel];
  target.el.style.width = target.size + 'px';
  target.el.style.height = target.size + 'px';
  // æ›´æ–° font-size ç›¸å¯¹å¤§å°
  if(emojiSpan) emojiSpan.style.fontSize = Math.round(target.size*0.55) + 'px';

  // æºæ·¡å‡ºå¹¶ç§»é™¤
  source.el.style.transition = 'transform 160ms, opacity 160ms';
  source.el.style.transform = 'scale(0.35)';
  source.el.style.opacity = '0';
  setTimeout(()=> safeRemoveTileById(source.id), 200);

  // ç›®æ ‡æ”¾å¤§å¼¹è·³æç¤º
  target.el.classList.add('dragging');
  target.el.style.transform = 'scale(1.18)';
  setTimeout(()=>{ target.el.style.transform=''; target.el.classList.remove('dragging'); }, 280);

  // å¾—åˆ†ä¸ç”Ÿæˆæ–°å—
  score += 10 * (nextLevel + 1);
  updateScore();
  setTimeout(()=>{ spawnRandom(BASE_LEVEL); ensurePossibleMerge(); }, 260);

  // èƒœåˆ©æ£€æµ‹
  if(nextLevel === EMOJIS.length - 1){
    setTimeout(()=> showWin(nextLevel), 420);
  }
}

// ç‰©ç†å¾ªç¯ï¼šåº”ç”¨é‡åŠ›ã€é€Ÿåº¦ã€ç®€å•ç¢°æ’åˆ†ç¦»
function physicsStep(dt){
  if(!boardRect) measureBoard();
  // ç§»åŠ¨æ¯ä¸ª tile
  for(const t of tiles){
    // apply gravity
    t.vx += gravity.x * dt * GRAVITY_SCALE;
    t.vy += gravity.y * dt * GRAVITY_SCALE;
    // integrate
    t.x += t.vx * dt;
    t.y += t.vy * dt;
    // world bounds
    if(t.x < 6){ t.x = 6; t.vx *= -0.2; }
    if(t.y < 6){ t.y = 6; t.vy *= -0.2; }
    const maxX = boardRect.width - t.size - 6;
    const maxY = boardRect.height - t.size - 6;
    if(t.x > maxX){ t.x = maxX; t.vx *= -0.2; }
    if(t.y > maxY){ t.y = maxY; t.vy *= -0.2; }
  }
  // ç®€å•ç¢°æ’åˆ†ç¦»ï¼ˆO(n^2)ï¼Œtileæ•°é‡å—é™ï¼‰
  for(let i=0;i<tiles.length;i++){
    for(let j=i+1;j<tiles.length;j++){
      const a = tiles[i], b = tiles[j];
      const ax = a.x + a.size/2, ay = a.y + a.size/2;
      const bx = b.x + b.size/2, by = b.y + b.size/2;
      const dx = bx-ax, dy = by-ay;
      const dist = Math.hypot(dx,dy) || 0.0001;
      const minDist = (a.size + b.size)/2 * 0.92;
      if(dist < minDist){
        // push them apart proportional to overlap
        const overlap = (minDist - dist) / 2;
        const nx = dx/dist, ny = dy/dist;
        a.x -= nx * overlap;
        a.y -= ny * overlap;
        b.x += nx * overlap;
        b.y += ny * overlap;
        // exchange some velocities (inelastic)
        const rvx = (b.vx - a.vx) * 0.2;
        const rvy = (b.vy - a.vy) * 0.2;
        a.vx -= rvx; a.vy -= rvy;
        b.vx += rvx; b.vy += rvy;
      }
    }
  }
  // friction
  for(const t of tiles){ t.vx *= FRICTION; t.vy *= FRICTION; t.el.style.left = t.x + 'px'; t.el.style.top = t.y + 'px'; }
}

// åŠ¨ç”»ä¸åˆæˆæ£€æµ‹å¾ªç¯
function loop(ts){
  if(!lastTimestamp) lastTimestamp = ts;
  const dt = Math.min(40, ts - lastTimestamp); // ms
  lastTimestamp = ts;
  physicsStep(dt/16.67); // çº¦åŒ–ä¸ºâ€œå¸§å•ä½â€
  // åˆæˆæ£€æµ‹ï¼šè·ä¸­å¿ƒæœ€è¿‘ä¸”æ»¡è¶³é˜ˆå€¼åˆ™åˆå¹¶ï¼ˆä¸ºäº†æ‰‹æ„Ÿï¼‰
  for(let i=0;i<tiles.length;i++){
    for(let j=i+1;j<tiles.length;j++){
      const a=tiles[i], b=tiles[j];
      if(a && b && a.level===b.level && tryMerge(a,b)){
        // åˆå¹¶ï¼šæŠŠ a åˆåˆ° b (ä¿æŒç¨³å®šæ–¹å‘)
        doMerge(a,b);
        break;
      }
    }
  }
  // è‹¥æ²¡æœ‰å¯åˆå¹¶å¯¹ä¸” tile è¾ƒå¤šï¼Œç¡®ä¿ç”Ÿæˆä¸€å¯¹
  ensurePossibleMerge();
  if(animationRunning) requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

// æ‹–æ‹½æ”¯æŒï¼ˆè§¦æ‘¸/é¼ æ ‡ï¼‰ï¼Œæ‹–åŠ¨æ—¶ä¼šæŠŠ tile ç½®ä¸ºâ€œæ‹–æ‹½çŠ¶æ€â€ï¼ˆæ¸…é›¶é€Ÿåº¦ï¼‰
function makeDraggable(el){
  let dragging=false, startX=0, startY=0, offsetX=0, offsetY=0, tile=null;
  const id = el.dataset.id;
  function begin(x,y){
    measureBoard();
    const idx = findTileIndexById(id);
    if(idx===-1) return;
    tile = tiles[idx];
    dragging=true;
    el.classList.add('dragging');
    tile.vx = tile.vy = 0;
    startX = x; startY = y;
    offsetX = x - tile.x; offsetY = y - tile.y;
    el.style.transition = 'transform 0ms';
  }
  function move(x,y){
    if(!dragging || !tile) return;
    let nx = x - offsetX, ny = y - offsetY;
    nx = Math.max(6, Math.min(boardRect.width - tile.size - 6, nx));
    ny = Math.max(6, Math.min(boardRect.height - tile.size - 6, ny));
    tile.x = nx; tile.y = ny;
    el.style.left = nx + 'px'; el.style.top = ny + 'px';
    // æç¤ºå°†è¿‘å¯åˆå¹¶çš„ target
    const {tile:near, dist} = findNearest(tile);
    if(near && tile.level === near.level && dist < (tile.size+near.size)*0.62){
      near.el.style.boxShadow = '0 18px 36px rgba(255,120,140,0.22)';
      near.el.style.transform = 'scale(1.06)';
    } else {
      tiles.forEach(t=>{ t.el.style.boxShadow=''; t.el.style.transform=''; });
    }
  }
  function end(){
    if(!dragging || !tile){ cleanup(); return; }
    const {tile:near, dist} = findNearest(tile);
    if(near && tryMerge(tile, near)){
      // åˆå¹¶ tile -> near
      doMerge(tile, near);
    } else {
      // æŠŠæ‹–åŠ¨é‡Šæ”¾çš„é€Ÿåº¦è®¾ç½®ä¸ºé›¶ï¼Œè½»å¾®å›å¼¹ï¼ˆå·²ç»åœ¨ç‰©ç†å¾ªç¯é‡Œï¼‰
      tile.vx = 0; tile.vy = 0;
    }
    tiles.forEach(t=>{ t.el.style.boxShadow=''; t.el.style.transform=''; });
    el.classList.remove('dragging');
    dragging=false; tile=null;
  }
  function cleanup(){ dragging=false; tile=null; el.classList.remove('dragging'); }

  // touch
  el.addEventListener('touchstart', (e)=>{ e.preventDefault(); const t=e.changedTouches[0]; begin(t.clientX - boardRect.left, t.clientY - boardRect.top); }, {passive:false});
  el.addEventListener('touchmove', (e)=>{ e.preventDefault(); const t=e.changedTouches[0]; move(t.clientX - boardRect.left, t.clientY - boardRect.top); }, {passive:false});
  el.addEventListener('touchend', (e)=>{ e.preventDefault(); end(); }, {passive:false});
  el.addEventListener('touchcancel', (e)=>{ cleanup(); }, {passive:false});

  // mouse
  el.addEventListener('mousedown', (e)=>{ e.preventDefault(); begin(e.clientX - boardRect.left, e.clientY - boardRect.top);
    function onMove(ev){ move(ev.clientX - boardRect.left, ev.clientY - boardRect.top); }
    function onUp(){ end(); window.removeEventListener('mousemove', onMove); window.removeEventListener('mouseup', onUp); }
    window.addEventListener('mousemove', onMove); window.addEventListener('mouseup', onUp);
  });
}

// åˆ†äº«ä¸ UI
shareBtn.addEventListener('click', ()=>{ navigator.clipboard?.writeText(location.href).then(()=>alert('å·²å¤åˆ¶é“¾æ¥')); });
resetBtn.addEventListener('click', ()=> init());
winReset.addEventListener('click', ()=>{ init(); hideWin(); });
closeWin.addEventListener('click', ()=> hideWin());

function showWin(level){ winEmoji.textContent = EMOJIS[level]; overlay.style.display = 'flex'; overlay.style.pointerEvents = 'auto'; }
function hideWin(){ overlay.style.display = 'none'; overlay.style.pointerEvents = 'none'; updateScore(); }

// åˆå§‹åŒ–ï¼šæµ‹é‡å¹¶ç”Ÿæˆ
function init(){
  tiles.forEach(t=>{ try{ if(t.el && t.el.parentNode) t.el.parentNode.removeChild(t.el); }catch(e){} });
  tiles = []; score=0; tileIdCounter=1; updateScore(); board.innerHTML=''; document.getElementById('overlay').style.display='none';
  measureBoard();
  for(let i=0;i<SPAWN_COUNT_INITIAL;i++) spawnRandom(BASE_LEVEL);
  // ç¡®ä¿è‡³å°‘å­˜åœ¨ä¸€ä¸ªå¯åˆå¹¶å¯¹ä»¥é¿å…ç«‹å³æ­»å±€
  ensurePossibleMerge();
}

// è®¾å¤‡æ–¹å‘ï¼ˆé‡åŠ›ï¼‰å¤„ç†
function handleOrientation(e){
  // e.beta (front-back, -180..180), e.gamma (left-right, -90..90)
  // æˆ‘ä»¬å°† gamma -> x, beta -> y
  const gamma = e.gamma || 0;
  const beta = e.beta || 0;
  // æ˜ å°„ä¸ºå°çš„é‡åŠ›å‘é‡
  gravity.x = Math.max(-1, Math.min(1, gamma / 60)); // normalize
  gravity.y = Math.max(-1, Math.min(1.8, (beta - 30) / 90 + 0.5)); // make downward bias
}
if(window.DeviceOrientationEvent){
  window.addEventListener('deviceorientation', (e)=>{ handleOrientation(e); }, true);
} else {
  // fallback: small constant gravity
  gravity = {x:0, y:0.6};
}

// é˜²æ­¢é¡µé¢æ»šåŠ¨å½±å“æ¸¸æˆï¼ˆç§»åŠ¨ç«¯ï¼‰
let touchStartY = null;
document.addEventListener('touchstart', (e)=>{ touchStartY = e.touches[0].clientY; }, {passive:true});
document.addEventListener('touchmove', (e)=>{
  const t = e.touches[0];
  const el = document.elementFromPoint(t.clientX, t.clientY);
  if(el && (el.closest && el.closest('.board'))){ e.preventDefault(); }
},{passive:false});

// çª—å£å˜åŒ–æ—¶é‡æ–°æµ‹é‡
window.addEventListener('resize', ()=> measureBoard());

// é¦–æ¬¡åŠ è½½
window.addEventListener('load', ()=>{ setTimeout(()=>{ measureBoard(); init(); }, 160); });

</script>
</body>
</html>