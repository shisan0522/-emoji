<!doctype html>
<html lang="zh-CN">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover, user-scalable=no" />
<title>åˆæˆEmoji Â· äº¤äº’é‡åŠ›ç‰ˆ</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Quicksand:wght@600;700&display=swap');

  :root{
    --bg1:#fff9f4; --bg2:#ffeef6; --pink:#f08ba0;
  }
  html,body{height:100%;margin:0;-webkit-user-select:none;user-select:none;touch-action:none;}
  body{
    font-family:'Quicksand', 'PingFang SC', 'Helvetica Neue', sans-serif;
    background: linear-gradient(180deg,var(--bg1),var(--bg2));
    display:flex;flex-direction:column;align-items:center;height:100vh;color:#5a4a42;
    -webkit-font-smoothing:antialiased;
  }

  header{width:100%;display:flex;align-items:center;justify-content:space-between;padding:12px 18px;box-sizing:border-box}
  .left{display:flex;gap:12px;align-items:center}
  .logo{width:44px;height:44px;border-radius:12px;background:linear-gradient(135deg,#fff,#ffe6f0);display:flex;align-items:center;justify-content:center;font-size:20px;box-shadow:0 8px 22px rgba(0,0,0,0.06)}
  h1{margin:0;font-size:16px;color:var(--pink)}
  .sub{font-size:12px;color:#8a6b6f;margin-top:4px}

  .controls{display:flex;gap:8px;align-items:center}
  button{border:0;padding:8px 12px;border-radius:12px;background:#fff4f6;box-shadow:0 6px 18px rgba(240,139,160,0.08);font-weight:700;color:#5a3a3f}
  button.small{padding:6px 10px;font-size:13px}

  /* æ¸¸æˆåŒºåŸŸ */
  #gameWrap{flex:1;width:100%;display:flex;align-items:center;justify-content:center;padding:8px;box-sizing:border-box}
  #game{
    width:92%;max-width:420px;height:calc(100vh - 160px);
    border-radius:22px;background:rgba(255,255,255,0.86);
    box-shadow:inset 0 0 20px rgba(255,182,193,0.08), 0 12px 36px rgba(20,12,12,0.06);
    position:relative;overflow:hidden;touch-action:none;
  }

  .emoji{
    position:absolute;display:flex;align-items:center;justify-content:center;border-radius:14px;
    width:56px;height:56px;line-height:1;user-select:none;touch-action:none;cursor:grab;
    transition:transform 140ms ease, box-shadow 140ms; will-change:transform,left,top;
    background:linear-gradient(180deg, rgba(255,255,255,0.9), rgba(255,255,255,0.86));
    box-shadow:0 10px 20px rgba(0,0,0,0.06);border:1px solid rgba(0,0,0,0.03);
  }
  .emoji.dragging{z-index:999; transform:scale(1.08); box-shadow:0 24px 44px rgba(0,0,0,0.16)}
  .hud{display:flex;flex-direction:column;align-items:flex-end;gap:6px}
  #score{background:#fff5f7;padding:8px 12px;border-radius:18px;font-weight:700;color:#6a3a41;box-shadow:0 6px 18px rgba(240,139,160,0.06)}
  .small{font-size:12px;color:#7a5b5f}

  .centerNotice{position:absolute;left:50%;top:10px;transform:translateX(-50%);pointer-events:none}
  #motionBtn{background:linear-gradient(90deg,#fff7f8,#fff2fb);padding:8px 12px;border-radius:12px;border:1px solid rgba(0,0,0,0.03)}

  footer{width:100%;display:flex;justify-content:space-between;padding:10px 18px;box-sizing:border-box;font-size:13px;color:#8a6b6f}
  .hint{opacity:0.92}
</style>
</head>
<body>
  <header>
    <div class="left">
      <div class="logo">ğŸ¬</div>
      <div>
        <h1>åˆæˆEmoji Â· äº¤äº’é‡åŠ›</h1>
        <div class="sub">ç«–å±ä¼˜å…ˆ Â· ç‚¹æŒ‰ä¸‹è½ Â· æ‹–æ‹½åˆæˆ</div>
      </div>
    </div>

    <div class="controls">
      <div class="hud">
        <div id="score">åˆ†æ•°ï¼š0</div>
        <div class="small">æœ€å¤šåŒæ—¶å­˜åœ¨å—ï¼š20</div>
      </div>
      <button id="resetBtn" class="small">é‡ç½®</button>
    </div>
  </header>

  <div id="gameWrap">
    <div id="game" aria-label="gameboard">
      <div class="centerNotice" id="centerNotice">
        <button id="motionBtn">å¯ç”¨å€¾æ–œæ§åˆ¶ï¼ˆç‚¹æˆ‘ï¼‰</button>
      </div>
    </div>
  </div>

  <footer>
    <div class="hint">æç¤ºï¼šç‚¹å‡»ï¼ˆæˆ–è§¦æ‘¸ï¼‰ä»»æ„ä½ç½®ç”Ÿæˆè¡¨æƒ…ï¼›æ‹–æ‹½å¯ç§»åŠ¨ï¼›ç›¸åŒè¡¨æƒ…ç¢°æ’åˆæˆå¹¶å˜å¤§</div>
    <div class="small">ä½¿ç”¨å…¬å¼€ Emoji â€¢ å…ç‰ˆæƒ</div>
  </footer>

<script>
/* ========== é…ç½®åŒº ========== */
const EMOJIS = ["ğŸ¥º","ğŸ¤¤","ğŸ¥°","ğŸ‘","ğŸ“","ğŸ","ğŸ‰","ğŸ‹","ğŸ¥","ğŸ”","ğŸ¥","ğŸ¤","ğŸ¥®","ğŸ˜","ğŸ‚","ğŸ®","â¤ï¸"];
const BASE_LEVEL = 0;
const MAX_TILES = 20;
const MERGE_DIST = 42;        // åˆæˆé˜ˆå€¼ï¼ˆåƒç´ ï¼‰
const BASE_SIZE = 56;         // åŸºç¡€è§†è§‰å¤§å°
const SIZE_STEP = 4;          // æ¯çº§å¢å¤§åƒç´ 
const GRAVITY_SCALE = 0.6;    // å€¾è§’å½±å“ç¼©æ”¾
/* ========================== */

const game = document.getElementById('game');
const scoreEl = document.getElementById('score');
const resetBtn = document.getElementById('resetBtn');
const motionBtn = document.getElementById('motionBtn');
let tiles = []; // {id, el, level, x,y, vx,vy, size}
let nextId = 1;
let score = 0;
let boardRect = null;
let gravity = {x:0, y:0.5}; // é»˜è®¤å¾®å‘ä¸‹
let lastTime = null;
let animRunning = true;

// æµ‹é‡ board åŒºåŸŸ
function measure(){ boardRect = game.getBoundingClientRect(); }

// åˆ›å»ºå¹¶æ’å…¥ä¸€ä¸ª emoji å…ƒç´ ï¼ˆåœ¨æŒ‡å®šåæ ‡ï¼‰
function spawnAt(level, cx, cy){
  if(tiles.length >= MAX_TILES) return;
  const id = 'e' + (nextId++);
  const size = BASE_SIZE + level*SIZE_STEP;
  const el = document.createElement('div');
  el.className = 'emoji';
  el.style.width = size + 'px';
  el.style.height = size + 'px';
  el.style.left = (cx - size/2) + 'px';
  el.style.top = (cy - size/2) + 'px';
  el.style.fontSize = Math.round(size*0.55) + 'px';
  el.dataset.id = id;
  el.dataset.level = level;
  el.textContent = EMOJIS[level];
  game.appendChild(el);

  const t = { id, el, level, x: cx - size/2, y: cy - size/2, vx:0, vy:0, size };
  tiles.push(t);

  enableDrag(t);
  return t;
}

// åœ¨éšæœº x ä¸Šæ–¹ç”Ÿæˆï¼ˆç‚¹å‡»æ›¿ä»£è‡ªåŠ¨ï¼‰
function spawnRandomAt(x){
  const cx = x;
  spawnAt(BASE_LEVEL, cx, 20);
}

// åˆ é™¤ tile
function removeTile(id){
  const idx = tiles.findIndex(t=>t.id===id);
  if(idx>=0){
    const t = tiles[idx];
    if(t.el && t.el.parentNode) t.el.parentNode.removeChild(t.el);
    tiles.splice(idx,1);
  }
}

// æ›´æ–°åˆ†æ•°æ˜¾ç¤º
function updateScore(){ scoreEl.textContent = 'åˆ†æ•°ï¼š' + score; }

// ç®€å•åœ†ç¢°æ’åˆ†ç¦»ï¼ˆO(n^2)ï¼Œn <= MAX_TILESï¼‰
function resolveCollisions(){
  for(let i=0;i<tiles.length;i++){
    for(let j=i+1;j<tiles.length;j++){
      const a = tiles[i], b = tiles[j];
      const ax = a.x + a.size/2, ay = a.y + a.size/2;
      const bx = b.x + b.size/2, by = b.y + b.size/2;
      const dx = bx - ax, dy = by - ay;
      const dist = Math.hypot(dx,dy) || 0.0001;
      const minDist = (a.size + b.size)/2 * 0.95;
      if(dist < minDist){
        const overlap = minDist - dist;
        const nx = dx/dist, ny = dy/dist;
        // move proportionally inverse to mass (mass ~ size)
        const totalMass = (a.size + b.size);
        const ma = b.size / totalMass;
        const mb = a.size / totalMass;
        a.x -= nx * overlap * ma;
        a.y -= ny * overlap * ma;
        b.x += nx * overlap * mb;
        b.y += ny * overlap * mb;
        // exchange a bit of velocity
        const rvx = (b.vx - a.vx) * 0.18;
        const rvy = (b.vy - a.vy) * 0.18;
        a.vx -= rvx; a.vy -= rvy;
        b.vx += rvx; b.vy += rvy;
      }
    }
  }
}

// åˆæˆæ£€æµ‹ï¼ˆåŒçº§ä¸”æ¥è§¦ï¼‰
function checkMerge(){
  for(let i=0;i<tiles.length;i++){
    for(let j=i+1;j<tiles.length;j++){
      const a = tiles[i], b = tiles[j];
      if(!a||!b) continue;
      if(a.level !== b.level) continue;
      const ax = a.x + a.size/2, ay = a.y + a.size/2;
      const bx = b.x + b.size/2, by = b.y + b.size/2;
      const d = Math.hypot(ax-bx, ay-by);
      if(d < MERGE_DIST){
        // åˆå¹¶ï¼šæŠŠ a åˆåˆ° bï¼ˆä¿ç•™ b çš„ä½ç½®ï¼‰
        doMerge(a, b);
        return; // æ¯å¸§åªå¤„ç†ä¸€ä¸ªåˆå¹¶ï¼Œé¿å…å†²çª
      }
    }
  }
}

// æ‰§è¡Œåˆå¹¶ï¼ˆsource -> targetï¼‰
function doMerge(source, target){
  if(source.id === target.id) return;
  if(source.level !== target.level) return;
  const next = Math.min(source.level + 1, EMOJIS.length - 1);
  // æ›´æ–° target è§†è§‰ä¸æ•°æ®
  target.level = next;
  target.el.dataset.level = next;
  target.size = BASE_SIZE + next*SIZE_STEP;
  target.el.style.width = target.size + 'px';
  target.el.style.height = target.size + 'px';
  target.el.style.fontSize = Math.round(target.size*0.56) + 'px';
  target.el.textContent = EMOJIS[next];
  // åŠ¨ç”»æ”¾å¤§
  target.el.classList.add('dragging');
  target.el.style.transform = 'scale(1.18)';
  setTimeout(()=>{ target.el.style.transform=''; target.el.classList.remove('dragging'); }, 260);

  // source æ·¡å‡ºç§»é™¤
  source.el.style.transition = 'transform 160ms, opacity 160ms';
  source.el.style.transform = 'scale(0.32)';
  source.el.style.opacity = '0';
  setTimeout(()=> removeTile(source.id), 180);

  // å¾—åˆ†
  score += 10 * (next + 1);
  updateScore();

  // ç”Ÿæˆä¸€ä¸ªè¡¥å……å—ï¼ˆé¿å…æ­»å±€ï¼‰
  setTimeout(()=> {
    // spawn near top at random x
    const x = Math.max(30, Math.random()*(boardRect.width-60));
    spawnAt(BASE_LEVEL, x, 20);
  }, 240);

  // èƒœåˆ©æç¤ºï¼ˆè‹¥åˆ°è¾¾æœ€åä¸€ä¸ªï¼‰
  if(next === EMOJIS.length - 1){
    setTimeout(()=> alert('æ­å–œï¼ä½ åˆæˆåˆ°æœ€é«˜ç­‰çº§ï¼š' + EMOJIS[next]), 300);
  }
}

// ç‰©ç†å¾ªç¯
function physicsStep(dt){
  // dt in ms; scale to ~ frames
  for(const t of tiles){
    // apply gravity vector to velocities
    t.vx += gravity.x * dt * 0.02;
    t.vy += gravity.y * dt * 0.02;
    // integrate
    t.x += t.vx * dt * 0.02;
    t.y += t.vy * dt * 0.02;
    // boundary
    if(t.x < 6){ t.x = 6; t.vx *= -0.18; }
    if(t.y < 6){ t.y = 6; t.vy *= -0.18; }
    const maxX = boardRect.width - t.size - 6;
    const maxY = boardRect.height - t.size - 6;
    if(t.x > maxX){ t.x = maxX; t.vx *= -0.18; }
    if(t.y > maxY){ t.y = maxY; t.vy *= -0.18; }
    // damping
    t.vx *= 0.995;
    t.vy *= 0.995;
    // apply to DOM
    t.el.style.left = t.x + 'px';
    t.el.style.top = t.y + 'px';
  }
  // collisions then merges
  resolveCollisions();
  checkMerge();
}

// ä¸»å¾ªç¯
function loop(ts){
  if(!lastTime) lastTime = ts;
  const dt = Math.min(40, ts - lastTime);
  lastTime = ts;
  physicsStep(dt);
  if(animRunning) requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

// æ‹–æ‹½å®ç°ï¼ˆtouch + mouseï¼‰
function enableDrag(tile){
  const el = tile.el;
  let dragging = false, ox=0, oy=0;
  function start(x,y){
    measure();
    dragging = true;
    el.classList.add('dragging');
    ox = x - tile.x; oy = y - tile.y;
    tile.vx = tile.vy = 0;
  }
  function move(x,y){
    if(!dragging) return;
    tile.x = Math.max(6, Math.min(boardRect.width - tile.size - 6, x - ox));
    tile.y = Math.max(6, Math.min(boardRect.height - tile.size - 6, y - oy));
    el.style.left = tile.x + 'px';
    el.style.top = tile.y + 'px';
  }
  function end(){
    dragging = false;
    el.classList.remove('dragging');
  }

  // touch
  el.addEventListener('touchstart', (ev) => {
    ev.stopPropagation();
    const t = ev.changedTouches[0];
    start(t.clientX - boardRect.left, t.clientY - boardRect.top);
  }, {passive:false});
  el.addEventListener('touchmove', (ev) => {
    ev.preventDefault();
    const t = ev.changedTouches[0];
    move(t.clientX - boardRect.left, t.clientY - boardRect.top);
  }, {passive:false});
  el.addEventListener('touchend', (ev) => { end(); }, {passive:false});
  el.addEventListener('touchcancel', ()=> end(), {passive:false});

  // mouse (desktop testing)
  el.addEventListener('mousedown', (e) => {
    e.preventDefault();
    start(e.clientX - boardRect.left, e.clientY - boardRect.top);
    function onMove(ev){ move(ev.clientX - boardRect.left, ev.clientY - boardRect.top); }
    function onUp(){ end(); window.removeEventListener('mousemove', onMove); window.removeEventListener('mouseup', onUp); }
    window.addEventListener('mousemove', onMove); window.addEventListener('mouseup', onUp);
  });
}

// ç‚¹å‡»æ¸¸æˆåŒºç”Ÿæˆï¼ˆä½ è¦æ±‚ï¼šç”¨æˆ·ç‚¹ä»»ä½•ä½ç½®ä¸‹è½ï¼‰
game.addEventListener('touchstart', (e) => {
  e.preventDefault();
  measure();
  const t = e.changedTouches[0];
  const x = t.clientX - boardRect.left;
  spawnRandomAt(Math.max(24, Math.min(boardRect.width-24, x)));
}, {passive:false});
game.addEventListener('mousedown', (e) => {
  measure();
  const x = e.clientX - boardRect.left;
  spawnRandomAt(Math.max(24, Math.min(boardRect.width-24, x)));
});

// iOS / Safari éœ€è¦ç”±ç”¨æˆ·æ‰‹åŠ¿è¯·æ±‚æƒé™
function requestMotion(){
  if(typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function'){
    DeviceMotionEvent.requestPermission().then(resp => {
      if(resp === 'granted'){ enableMotionListeners(); motionBtn.textContent='å€¾æ–œå·²å¯ç”¨'; motionBtn.disabled=true; }
      else { alert('æœªæˆæƒé‡åŠ›æ„Ÿåº”ï¼Œä»å¯é€šè¿‡ç‚¹å‡»ç”Ÿæˆå¹¶æ‹–æ‹½æ¸¸ç©'); }
    }).catch(()=> alert('æˆæƒå¤±è´¥æˆ–è¢«æµè§ˆå™¨é˜»æ­¢'));
  } else {
    // é iOS æˆ–æ— æƒé™ API
    enableMotionListeners();
    motionBtn.textContent='å€¾æ–œå·²å¯ç”¨'; motionBtn.disabled=true;
  }
}
motionBtn.addEventListener('click', requestMotion);

// ç»‘å®šé‡åŠ›æ•°æ®
function enableMotionListeners(){
  if(window.DeviceOrientationEvent){
    window.addEventListener('deviceorientation', (ev)=>{
      // ev.gamma: left-right (-90..90), ev.beta: front-back (-180..180)
      const gamma = ev.gamma || 0;
      const beta = ev.beta || 0;
      // map to small gravity vector
      gravity.x = Math.max(-1.4, Math.min(1.4, gamma / 45 * GRAVITY_SCALE));
      gravity.y = Math.max(-1.2, Math.min(2.0, (beta - 10) / 90 * GRAVITY_SCALE + 0.3));
    }, true);
  } else if(window.DeviceMotionEvent){
    window.addEventListener('devicemotion', (ev)=>{
      const a = ev.accelerationIncludingGravity;
      if(!a) return;
      gravity.x = (a.x || 0) * 0.06;
      gravity.y = (-(a.y || 0)) * 0.06 + 0.4;
    }, true);
  } else {
    // fallback no-op
  }
}

// é‡ç½®
resetBtn.addEventListener('click', ()=> {
  tiles.forEach(t=>{ try{ if(t.el && t.el.parentNode) t.el.parentNode.removeChild(t.el);}catch(e){}});
  tiles = []; nextId = 1; score = 0; updateScore();
});

// çª—å£å˜åŒ–
window.addEventListener('resize', ()=> measure());

// åˆå§‹ï¼šæµ‹é‡åå‡†å¤‡ï¼ˆä¸è‡ªåŠ¨äº§ç”Ÿï¼‰
window.addEventListener('load', ()=>{
  setTimeout(()=>{ measure(); /* ensure board size */ }, 120);
  updateScore();
});
</script>
</body>
</html>
