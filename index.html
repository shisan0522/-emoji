<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
<title>ğŸ“ åˆæˆEmoji Â· å¥¶æ²¹ç²‰é‡åŠ›ç‰ˆ</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=Quicksand:wght@600&display=swap');

body {
  margin: 0;
  background: linear-gradient(180deg, #fff8f3 0%, #ffeaf4 100%);
  font-family: 'Quicksand', 'PingFang SC', sans-serif;
  overflow: hidden;
  height: 100vh;
  display: flex;
  flex-direction: column;
  align-items: center;
  touch-action: none;
}
h1 {
  color: #f59bb4;
  text-shadow: 0 2px 6px rgba(245,155,180,0.3);
  margin: 10px 0 0;
}
#score {
  background: #fff0f5;
  padding: 6px 18px;
  border-radius: 20px;
  box-shadow: 0 3px 10px rgba(240,139,160,0.15);
  font-weight: bold;
}
#game {
  position: relative;
  flex: 1;
  width: 90%;
  max-width: 400px;
  background: rgba(255,255,255,0.85);
  border-radius: 30px;
  margin-top: 8px;
  box-shadow: inset 0 0 15px rgba(255,182,193,0.25);
  overflow: hidden;
}
.emoji {
  position: absolute;
  font-size: 48px;
  user-select: none;
  transition: transform 0.1s;
}
#tip {
  font-size: 0.85rem;
  opacity: 0.6;
  margin: 10px;
}
</style>
</head>
<body>
<h1>ğŸ° åˆæˆEmoji</h1>
<div id="score">åˆ†æ•°ï¼š0</div>
<div id="game"></div>
<div id="tip">ç‚¹å‡»ç”Ÿæˆï¼Œæ‹–åŠ¨åˆæˆï¼Œå€¾æ–œå¯æ»‘åŠ¨ ğŸ’•</div>

<script>
const EMOJIS = ["ğŸ¥º","ğŸ¤¤","ğŸ¥°","ğŸ‘","ğŸ“","ğŸ","ğŸ‰","ğŸ‹","ğŸ¥","ğŸ”","ğŸ¥","ğŸ¤","ğŸ¥®","ğŸ˜","ğŸ‚","ğŸ®","â¤ï¸"];
const game = document.getElementById("game");
const scoreDisplay = document.getElementById("score");
let score = 0;
const emojis = [];
const gravity = 0.4;
const friction = 0.98;
let gx = 0, gy = 0;

function createEmoji(level, x, y) {
  const div = document.createElement("div");
  div.className = "emoji";
  div.textContent = EMOJIS[level];
  div.style.left = x + "px";
  div.style.top = y + "px";
  div.style.fontSize = (48 + level * 3) + "px";
  game.appendChild(div);
  const obj = { el: div, level, x, y, vx: 0, vy: 0 };
  emojis.push(obj);
  return obj;
}

// ç‚¹å‡»ç”Ÿæˆ
game.addEventListener("pointerdown", e => {
  const rect = game.getBoundingClientRect();
  const x = e.clientX - rect.left - 25;
  createEmoji(0, x, 0);
  requestMotionPermission();
});

// æ‹–æ‹½äº‹ä»¶
game.addEventListener("pointermove", e => {
  if (!dragging) return;
  const rect = game.getBoundingClientRect();
  dragTarget.x = e.clientX - rect.left - dragOffset.x;
  dragTarget.y = e.clientY - rect.top - dragOffset.y;
});
game.addEventListener("pointerup", () => { dragging = false; });

let dragging = false, dragTarget = null, dragOffset = {x:0,y:0};
game.addEventListener("pointerdown", e => {
  const target = emojis.find(em => {
    const rect = em.el.getBoundingClientRect();
    return e.clientX >= rect.left && e.clientX <= rect.right &&
           e.clientY >= rect.top && e.clientY <= rect.bottom;
  });
  if (target) {
    dragging = true;
    dragTarget = target;
    dragOffset.x = e.clientX - target.x;
    dragOffset.y = e.clientY - target.y;
  }
});

// ç‰©ç†æ¨¡æ‹Ÿ
function update() {
  for (let e of emojis) {
    if (dragTarget === e && dragging) continue;
    e.vy += gravity + gy * 0.2;
    e.vx += gx * 0.2;
    e.x += e.vx;
    e.y += e.vy;

    // è¾¹ç•Œ
    const maxX = game.clientWidth - 50;
    const maxY = game.clientHeight - 60;
    if (e.x < 0) { e.x = 0; e.vx *= -0.5; }
    if (e.x > maxX) { e.x = maxX; e.vx *= -0.5; }
    if (e.y > maxY) { e.y = maxY; e.vy *= -0.4; }

    // ç¢°æ’æ£€æµ‹
    for (let o of emojis) {
      if (o === e) continue;
      const dx = e.x - o.x, dy = e.y - o.y;
      const dist = Math.hypot(dx, dy);
      if (dist < 45) {
        const overlap = 45 - dist;
        const nx = dx / dist, ny = dy / dist;
        e.x += nx * overlap / 2;
        e.y += ny * overlap / 2;
        o.x -= nx * overlap / 2;
        o.y -= ny * overlap / 2;

        // åˆæˆ
        if (e.level === o.level && dist < 30) {
          merge(e, o);
          break;
        } else { // å¼¹åŠ›ç¢°æ’
          const tmp = e.vx;
          e.vx = o.vx * 0.6;
          o.vx = tmp * 0.6;
          const tmpy = e.vy;
          e.vy = o.vy * 0.6;
          o.vy = tmpy * 0.6;
        }
      }
    }

    // è¡°å‡
    e.vx *= friction;
    e.vy *= friction;

    e.el.style.left = e.x + "px";
    e.el.style.top = e.y + "px";
  }
  requestAnimationFrame(update);
}

// åˆæˆé€»è¾‘
function merge(a, b) {
  const newLevel = Math.min(a.level + 1, EMOJIS.length - 1);
  const newX = (a.x + b.x)/2;
  const newY = (a.y + b.y)/2;
  a.el.remove();
  b.el.remove();
  emojis.splice(emojis.indexOf(a),1);
  emojis.splice(emojis.indexOf(b),1);
  createEmoji(newLevel, newX, newY);
  score += (newLevel + 1) * 10;
  scoreDisplay.textContent = "åˆ†æ•°ï¼š" + score;
}

update();

// é‡åŠ›æ„Ÿåº”
function requestMotionPermission() {
  if (typeof DeviceMotionEvent !== "undefined" && typeof DeviceMotionEvent.requestPermission === "function") {
    DeviceMotionEvent.requestPermission().then(res => {
      if (res === "granted") startMotion();
    });
  } else {
    startMotion();
  }
}
function startMotion() {
  window.addEventListener("devicemotion", e => {
    gx = e.accelerationIncludingGravity.x || 0;
    gy = e.accelerationIncludingGravity.y || 0;
  });
}
</script>
</body>
</html>
